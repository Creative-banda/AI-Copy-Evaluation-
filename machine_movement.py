import serial
import time
import os

# ============================================================
# GRBL MACHINE MOVEMENT TEST
# 1. Wake up GRBL
# 2. Set current position as Origin (0, 0) via G92
# 3. Send G-code from file, line by line with GRBL OK wait
# 4. Return to Origin when done
# ============================================================

PORT = "COM8"
BAUD = 115200
FEED_RATE = 1000  # mm/min - adjust to your machine speed

# ---- MACHINE PHYSICAL LIMITS ----
# Physical travel: 450mm (X) x 360mm (Y)
# G-code coordinates are pre-divided by scale_divider=3 in handwriting_system.py,
# so the machine physically moves 3x the G-code value.
# G-code safe limits = physical_limit / scale_divider
MAX_X_MM = 150.0   # 450mm / 3 = 150mm G-code limit
MAX_Y_MM = 120.0   # 360mm / 3 = 120mm G-code limit

# Path to the G-code file generated by the grading system
GCODE_FILE = os.path.join(os.path.dirname(__file__), "handwriting_output", "standalone_combined.gcode")


def send_and_wait(s: serial.Serial, line: str, timeout: float = 30.0) -> str:
    """Send a single G-code line and wait for GRBL 'ok' or 'error' response."""
    cmd = line.strip() + "\n"
    s.write(cmd.encode())
    print(f"  >> {line.strip()}")

    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            raw = s.readline()
        except serial.SerialException as e:
            print(f"  !! Serial error: {e}")
            return "error"
        if raw:
            response = raw.decode(errors='replace').strip()
            if response:
                print(f"  << {response}")
            if response.lower().startswith("ok") or response.lower().startswith("error"):
                return response
    print(f"  << TIMEOUT (no response within {timeout}s)")
    return "timeout"


def wait_for_idle(s: serial.Serial, timeout: float = 60.0):
    """Poll GRBL '?' status report until machine state becomes 'Idle'."""
    deadline = time.time() + timeout
    while time.time() < deadline:
        s.write(b"?\n")
        time.sleep(0.1)
        raw = s.read(s.in_waiting or 1)
        if raw:
            resp = raw.decode(errors='replace')
            if "Idle" in resp:
                return True
            if "Alarm" in resp:
                print("  !! Machine is in ALARM state!")
                return False
    print("  !! Timeout waiting for machine to become Idle.")
    return False


def run_gcode(gcode_path: str) -> bool:
    """
    Reusable machine execution function.
    Connects to GRBL, sends all G-code lines and waits for completion.
    Returns True if all lines sent successfully, False on error.
    Can be imported and called from automated_grading.py
    """
    import re
    coord_re = re.compile(r'([XY])(-?[\d.]+)')

    if not os.path.exists(gcode_path):
        print(f"[Machine] ERROR: G-Code file not found: {gcode_path}")
        return False

    with open(gcode_path, 'r') as f:
        raw_gcode = f.read()

    lines = [l.strip() for l in raw_gcode.strip().split("\n")
             if l.strip() and not l.strip().startswith(";")]

    print(f"[Machine] Loaded {len(lines)} G-code lines from: {gcode_path}")

    # --- Connect ---
    print(f"[Machine] Connecting to GRBL on {PORT} @ {BAUD}...")
    try:
        s = serial.Serial(PORT, BAUD, timeout=5)
    except serial.SerialException as e:
        print(f"[Machine] ERROR: Cannot open {PORT}: {e}")
        return False

    try:
        time.sleep(2)

        # Step 1: Wake up GRBL
        print("[Machine] Waking up GRBL...")
        s.write(b"\r\n\r\n")
        time.sleep(1.5)
        s.flushInput()

        # Step 1b: Clear Alarm Lock
        print("[Machine] Clearing Alarm Lock ($X)...")
        send_and_wait(s, "$X")

        # Step 2: Pen UP, set feed rate
        print("[Machine] Pen UP, setting feed rate...")
        send_and_wait(s, "M3 S1000")          # Pen UP first
        send_and_wait(s, f"F{FEED_RATE}")

        # Step 3: Send G-code line by line
        print(f"[Machine] Sending {len(lines)} G-code lines...")
        success = True
        for i, line in enumerate(lines, 1):
            if line.upper() in ("M2", "M30"):
                print(f"[Machine] End of program at line {i}.")
                break

            # Safety: skip moves that exceed machine physical limits
            coords = {axis: float(val) for axis, val in coord_re.findall(line)}
            if coords.get('X', 0) > MAX_X_MM or coords.get('Y', 0) > MAX_Y_MM:
                print(f"[Machine] SKIP line {i} (exceeds limits: {coords})")
                continue

            result = send_and_wait(s, line)
            if "error" in result.lower() or result == "timeout":
                print(f"[Machine] !! Stopping at line {i} due to: {result}")
                success = False
                break

        # Step 4: Final pen UP and return to origin
        print("[Machine] Drawing complete. Pen UP + return to origin...")
        send_and_wait(s, "M3 S1000")
        send_and_wait(s, "G00 X0 Y0")
        send_and_wait(s, "G4 P2")

        # Done signal
        send_and_wait(s, "M30")

        if success:
            print("[Machine] âœ… DONE - All marks drawn successfully!")
        return success

    except Exception as e:
        print(f"[Machine] !! Unexpected error: {e}")
        return False
    finally:
        try:
            s.close()
            print("[Machine] Port closed.")
        except Exception:
            pass


def main():
    """Standalone entry point - runs G-code from default GCODE_FILE."""
    run_gcode(GCODE_FILE)


if __name__ == "__main__":
    main()

