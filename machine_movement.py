import serial
import time
import os

# ============================================================
# GRBL MACHINE MOVEMENT TEST
# 1. Wake up GRBL
# 2. Set current position as Origin (0, 0) via G92
# 3. Send G-code from file, line by line with GRBL OK wait
# 4. Return to Origin when done
# ============================================================

PORT = "COM6"
BAUD = 115200
FEED_RATE = 1000  # mm/min - adjust to your machine speed

# Path to the G-code file generated by the grading system
GCODE_FILE = os.path.join(os.path.dirname(__file__), "handwriting_output", "a4_sheet.gcode")


def send_and_wait(s: serial.Serial, line: str, timeout: float = 30.0) -> str:
    """Send a single G-code line and wait for GRBL 'ok' or 'error' response."""
    cmd = line.strip() + "\n"
    s.write(cmd.encode())
    print(f"  >> {line.strip()}")

    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            raw = s.readline()
        except serial.SerialException as e:
            print(f"  !! Serial error: {e}")
            return "error"
        if raw:
            response = raw.decode(errors='replace').strip()
            if response:
                print(f"  << {response}")
            if response.lower().startswith("ok") or response.lower().startswith("error"):
                return response
    print(f"  << TIMEOUT (no response within {timeout}s)")
    return "timeout"


def main():
    # --- Load G-Code from file ---
    if not os.path.exists(GCODE_FILE):
        print(f"ERROR: G-Code file not found: {GCODE_FILE}")
        print("Run 'python automated_grading.py' first to generate the G-code.")
        return

    with open(GCODE_FILE, 'r') as f:
        raw_gcode = f.read()

    lines = [l.strip() for l in raw_gcode.strip().split("\n")
             if l.strip() and not l.strip().startswith(";")]

    print(f"Loaded {len(lines)} G-code lines from: {GCODE_FILE}")

    # --- Connect ---
    print(f"\nConnecting to GRBL on {PORT} @ {BAUD}...")
    try:
        s = serial.Serial(PORT, BAUD, timeout=5)
    except serial.SerialException as e:
        print(f"ERROR: Cannot open {PORT}: {e}")
        return
    time.sleep(2)

    # --- Step 1: Wake up GRBL ---
    print("\n[1] Waking up GRBL...")
    s.write(b"\r\n\r\n")
    time.sleep(1.5)
    s.flushInput()  # Clear boot messages / pending data

    # --- Step 1b: Clear Alarm Lock ---
    # GRBL enters alarm state on power-on or after hitting limit switches.
    # $X unlocks it so commands can be accepted.
    print("\n[1b] Clearing Alarm Lock ($X)...")
    send_and_wait(s, "$X")

    # --- Step 2: Return to Machine Zero ---
    # Moves the machine back to the absolute (0,0) before starting.
    # Note: (0,0) is wherever the machine was powered on, unless you previously sent G92 X0 Y0.
    # IMPORTANT: Your machine's physical (0, 0) should be placed at the
    # BOTTOM-LEFT corner of the left-most paper, not the top-left!
    print("\n[2] Returning to physical absolute Origin (G00 X0 Y0)...")
    send_and_wait(s, "G90") # Absolute positioning
    send_and_wait(s, "G00 X0 Y0") # Move to origin
    send_and_wait(s, f"F{FEED_RATE}")

    # --- Step 3: Send G-code line by line ---
    print(f"\n[3] Sending {len(lines)} G-code lines...")
    for i, line in enumerate(lines, 1):
        if line.upper() == "M2":
            print(f"\n  [{i}/{len(lines)}] End of Program (M2). Stopping.")
            break

        result = send_and_wait(s, line)
        if "error" in result.lower() or result == "timeout":
            print(f"\n  !! Stopping at line {i} due to: {result}")
            break

    # --- Step 4: Return to Origin ---
    print("\n[4] Returning to Origin (G00 X0 Y0)...")
    send_and_wait(s, "G00 X0 Y0")

    print("\n[DONE] Closing port.")
    s.close()


if __name__ == "__main__":
    main()