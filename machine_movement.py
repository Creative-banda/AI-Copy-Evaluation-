import serial
import time
import os

# ============================================================
# GRBL MACHINE MOVEMENT TEST
# 1. Wake up GRBL
# 2. Set current position as Origin (0, 0) via G92
# 3. Send G-code from file, line by line with GRBL OK wait
# 4. Return to Origin when done
# ============================================================

PORT = "COM8"
BAUD = 115200
FEED_RATE = 1000  # mm/min - adjust to your machine speed

# Path to the G-code file generated by the grading system
GCODE_FILE = os.path.join(os.path.dirname(__file__), "handwriting_output", "standalone_combined.gcode")


def send_and_wait(s: serial.Serial, line: str, timeout: float = 30.0) -> str:
    """Send a single G-code line and wait for GRBL 'ok' or 'error' response."""
    cmd = line.strip() + "\n"
    s.write(cmd.encode())
    print(f"  >> {line.strip()}")

    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            raw = s.readline()
        except serial.SerialException as e:
            print(f"  !! Serial error: {e}")
            return "error"
        if raw:
            response = raw.decode(errors='replace').strip()
            if response:
                print(f"  << {response}")
            if response.lower().startswith("ok") or response.lower().startswith("error"):
                return response
    print(f"  << TIMEOUT (no response within {timeout}s)")
    return "timeout"


def wait_for_idle(s: serial.Serial, timeout: float = 60.0):
    """Poll GRBL '?' status report until machine state becomes 'Idle'."""
    deadline = time.time() + timeout
    while time.time() < deadline:
        s.write(b"?\n")
        time.sleep(0.1)
        raw = s.read(s.in_waiting or 1)
        if raw:
            resp = raw.decode(errors='replace')
            if "Idle" in resp:
                return True
            if "Alarm" in resp:
                print("  !! Machine is in ALARM state!")
                return False
    print("  !! Timeout waiting for machine to become Idle.")
    return False


def main():
    # --- Load G-Code from file ---
    if not os.path.exists(GCODE_FILE):
        print(f"ERROR: G-Code file not found: {GCODE_FILE}")
        print("Run 'python standalone_gcode_test.py' first to generate the G-code.")
        return

    with open(GCODE_FILE, 'r') as f:
        raw_gcode = f.read()

    lines = [l.strip() for l in raw_gcode.strip().split("\n")
             if l.strip() and not l.strip().startswith(";")]

    print(f"Loaded {len(lines)} G-code lines from: {GCODE_FILE}")

    # --- Connect ---
    print(f"\nConnecting to GRBL on {PORT} @ {BAUD}...")
    try:
        s = serial.Serial(PORT, BAUD, timeout=5)
    except serial.SerialException as e:
        print(f"ERROR: Cannot open {PORT}: {e}")
        return
    time.sleep(2)

    # --- Step 1: Wake up GRBL ---
    print("\n[1] Waking up GRBL...")
    s.write(b"\r\n\r\n")
    time.sleep(1.5)
    s.flushInput()

    # --- Step 1b: Clear Alarm Lock ---
    print("\n[1b] Clearing Alarm Lock ($X)...")
    send_and_wait(s, "$X")

    # --- Step 2: Servo UP before moving, then go to origin ---
    print("\n[2] Pen UP then moving to Origin (0, 0)...")
    send_and_wait(s, "S1000")        # Pen UP first - don't drag on the way to origin
    send_and_wait(s, "G90")          # Absolute positioning
    send_and_wait(s, "G00 X0 Y0")   # Move to absolute origin
    send_and_wait(s, f"F{FEED_RATE}")

    # Wait until the machine physically reaches origin before drawing
    print("  Waiting for machine to reach origin...")
    wait_for_idle(s, timeout=60)
    print("  -> Machine is at origin. Starting drawing.")

    # --- Step 3: Send G-code line by line ---
    print(f"\n[3] Sending {len(lines)} G-code lines...")
    drawing_done = False
    for i, line in enumerate(lines, 1):
        if line.upper() in ("M2", "M30"):
            print(f"\n  [{i}/{len(lines)}] End of Program ({line}). Finishing up.")
            drawing_done = True
            break

        result = send_and_wait(s, line)
        if "error" in result.lower() or result == "timeout":
            print(f"\n  !! Stopping at line {i} due to: {result}")
            break

    # --- Step 4: Pen UP, return to Origin, signal done ---
    print("\n[4] Drawing complete. Lifting pen and returning to Origin...")
    send_and_wait(s, "S1000")        # Pen UP
    send_and_wait(s, "G00 X0 Y0")   # Return to origin

    # Wait until physically home
    wait_for_idle(s, timeout=60)

    # Send M30 as the "done" signal (hardware person can read this)
    send_and_wait(s, "M30")

    print("\n" + "=" * 50)
    print("  âœ… MACHINE DONE - All marks have been drawn!")
    print("=" * 50)

    s.close()


if __name__ == "__main__":
    main()
