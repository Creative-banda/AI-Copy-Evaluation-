import serial
import time
import os

# ============================================================
# GRBL MACHINE MOVEMENT TEST
# 1. Wake up GRBL
# 2. Set current position as Origin (0, 0) via G92
# 3. Send G-code from file, line by line with GRBL OK wait
# 4. Return to Origin when done
# ============================================================

PORT = "COM8"
BAUD = 115200
FEED_RATE = 1000  # mm/min - adjust to your machine speed

# ---- MACHINE PHYSICAL LIMITS ----
# Physical travel: 450mm (X) x 360mm (Y)
# G-code coordinates are pre-divided by scale_divider=3 in handwriting_system.py,
# so the machine physically moves 3x the G-code value.
# G-code safe limits = physical_limit / scale_divider
MAX_X_MM = 150.0   # 450mm / 3 = 150mm G-code limit
MAX_Y_MM = 120.0   # 360mm / 3 = 120mm G-code limit

# Path to the G-code file generated by the grading system
GCODE_FILE = os.path.join(os.path.dirname(__file__), "handwriting_output", "standalone_combined.gcode")


def send_and_wait(s: serial.Serial, line: str, timeout: float = 30.0) -> str:
    """Send a single G-code line and wait for GRBL 'ok' or 'error' response."""
    cmd = line.strip() + "\n"
    s.write(cmd.encode())
    print(f"  >> {line.strip()}")

    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            raw = s.readline()
        except serial.SerialException as e:
            print(f"  !! Serial error: {e}")
            return "error"
        if raw:
            response = raw.decode(errors='replace').strip()
            if response:
                print(f"  << {response}")
            if response.lower().startswith("ok") or response.lower().startswith("error"):
                return response
    print(f"  << TIMEOUT (no response within {timeout}s)")
    return "timeout"


def wait_for_idle(s: serial.Serial, timeout: float = 60.0):
    """Poll GRBL '?' status report until machine state becomes 'Idle'."""
    deadline = time.time() + timeout
    while time.time() < deadline:
        s.write(b"?\n")
        time.sleep(0.1)
        raw = s.read(s.in_waiting or 1)
        if raw:
            resp = raw.decode(errors='replace')
            if "Idle" in resp:
                return True
            if "Alarm" in resp:
                print("  !! Machine is in ALARM state!")
                return False
    print("  !! Timeout waiting for machine to become Idle.")
    return False


def main():
    # --- Load G-Code from file ---
    if not os.path.exists(GCODE_FILE):
        print(f"ERROR: G-Code file not found: {GCODE_FILE}")
        print("Run 'python standalone_gcode_test.py' first to generate the G-code.")
        return

    with open(GCODE_FILE, 'r') as f:
        raw_gcode = f.read()

    lines = [l.strip() for l in raw_gcode.strip().split("\n")
             if l.strip() and not l.strip().startswith(";")]

    print(f"Loaded {len(lines)} G-code lines from: {GCODE_FILE}")

    # --- Connect ---
    print(f"\nConnecting to GRBL on {PORT} @ {BAUD}...")
    try:
        s = serial.Serial(PORT, BAUD, timeout=5)
    except serial.SerialException as e:
        print(f"ERROR: Cannot open {PORT}: {e}")
        return
    time.sleep(2)

    # --- Step 1: Wake up GRBL ---
    print("\n[1] Waking up GRBL...")
    s.write(b"\r\n\r\n")
    time.sleep(1.5)
    s.flushInput()

    # --- Step 1b: Clear Alarm Lock ---
    print("\n[1b] Clearing Alarm Lock ($X)...")
    send_and_wait(s, "$X")

    # --- Step 2: Pen UP, move to home (0,0), then wait ---
    print("\n[2] Pen UP then moving to Home (G00 X0 Y0)...")
    send_and_wait(s, "M3 S1000")     # Pen UP first - don't drag on the way home
    send_and_wait(s, "G90")           # Absolute positioning mode
    send_and_wait(s, "G00 X0 Y0")    # Move to origin (0,0)
    send_and_wait(s, "G4 P3")         # Dwell 3s - wait for machine to physically reach home
    send_and_wait(s, f"F{FEED_RATE}")
    print("  -> Machine is at Home/Origin. Starting drawing.")

    # --- Step 3: Send G-code line by line ---
    import re
    coord_re = re.compile(r'([XY])(-?[\d.]+)')
    print(f"\n[3] Sending {len(lines)} G-code lines...")
    drawing_done = False
    for i, line in enumerate(lines, 1):
        if line.upper() in ("M2", "M30"):
            print(f"\n  [{i}/{len(lines)}] End of Program ({line}). Finishing up.")
            drawing_done = True
            break

        # Safety: skip any move that would exceed machine physical limits
        coords = {axis: float(val) for axis, val in coord_re.findall(line)}
        if coords.get('X', 0) > MAX_X_MM or coords.get('Y', 0) > MAX_Y_MM:
            print(f"  !! SKIP line {i} (would exceed limits: {coords}) - {line.strip()}")
            continue

        result = send_and_wait(s, line)
        if "error" in result.lower() or result == "timeout":
            print(f"\n  !! Stopping at line {i} due to: {result}")
            break

    # --- Step 4: Pen UP, return to Origin, signal done ---
    print("\n[4] Drawing complete. Lifting pen and returning to Origin...")
    send_and_wait(s, "M3 S1000")      # Pen UP
    send_and_wait(s, "G00 X0 Y0")    # Return to origin
    send_and_wait(s, "G4 P2")         # Dwell 2 seconds - waits inside motion planner until home

    # Send M30 as the "done" signal (hardware person can read this)
    send_and_wait(s, "M30")

    print("\n" + "=" * 50)
    print("  âœ… MACHINE DONE - All marks have been drawn!")
    print("=" * 50)

    s.close()


if __name__ == "__main__":
    main()
